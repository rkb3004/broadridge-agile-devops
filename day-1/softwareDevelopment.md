# Software Engineering Fundamentals - Day 1

Welcome to Day 1 of the **Software Engineering** series. This session laid the foundation for understanding the discipline of Software Engineering and introduced fundamental concepts, development styles, and the need for systematic practices. Below is a comprehensive summary for quick reference.

---

## 📘 Topics Covered

1. What is Software Engineering?
2. Evolution of Software Engineering
3. Issues with the Exploratory Style
4. Human Cognition and Programming
5. Principles to Overcome Cognitive Limitations
6. Importance of Software Engineering
7. Software Crisis
8. Programs vs Software Products
9. Computer Systems Engineering
10. Life Cycle Models - Introduction
11. Summary

---

## 🔧 What is Software Engineering?

Software Engineering is an **engineering-based approach** to software development that emphasizes:

- Use of past experience and theory
- Systematic development process
- Pragmatic trade-offs for cost-effectiveness
- A scientific and measurable foundation

> **Analogy:** Similar to how buildings are constructed using engineering principles.

---

## 🧠 Why Exploratory Programming Fails

- Suitable only for very small programs
- Exponential increase in effort with size
- Difficult to maintain
- Not suitable for team development

---

## 🧬 Human Cognition Limitations

- **Short-Term Memory** is limited to 7±2 items
- **Chunking** can help group related info to increase comprehension
- Software Engineering helps overcome these limitations via:

### 🔑 Key Techniques

- **Abstraction**: Focus on important details
- **Decomposition**: Break large problems into manageable parts

---

## 📈 Evolution of Programming Practices

| Era                 | Characteristics                                |
|---------------------|------------------------------------------------|
| 1950s               | Assembly language, ad hoc, exploratory          |
| Early 60s           | High-level languages (FORTRAN, COBOL, ALGOL)   |
| Late 60s            | Control flow-based design, GOTO issues         |
| Early 70s           | Data structure-oriented design (JSP)           |
| Late 70s            | Data flow-oriented design                      |
| 1980s               | Object-oriented design (classes, reuse, etc.)  |

---

## ❗ Software Crisis

- Poor quality software
- Delayed delivery
- Hard to maintain and enhance
- User requirements often unmet

---

## 🆚 Programs vs Software Products

| Programs                          | Software Products                      |
|----------------------------------|----------------------------------------|
| Small, single-user               | Large, multi-user                      |
| Ad hoc, no documentation         | Systematic, well-documented            |
| No user interface                | Well-designed UI                       |
| Written by single developer      | Built by teams                         |

---

## 🔄 Introduction to Life Cycle Models

The **software life cycle** is a sequence of stages for software development:

1. Feasibility Study
2. Requirements Analysis & Specification
3. Design
4. Coding
5. Testing
6. Maintenance

> The **life cycle model** provides structure and discipline in software development and project management.

---

## 📝 Summary

- Software Engineering systematizes programming using tested methodologies.
- It addresses human limitations through abstraction and decomposition.
- Life cycle models improve planning, visibility, and reliability in projects.
- Modern software development is **documented, measurable, maintainable**, and **collaborative**.

---

Stay prepared for **Day 2**, where we’ll explore life cycle models like **Waterfall**, **Iterative**, **Prototype**, and **Spiral** in depth.

